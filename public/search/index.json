[{"content":"上一期已经实现了配置文件的读取，这一期来实现数据库的配置\n数据库配置 这里使用的是 MySQL 数据库，orm框架使用的是 sqlx,执行下列命令获取 sqlx 和 mysql 驱动\n1 2 go get github.com/jmoiron/sqlx go get github.com/go-sql-driver/mysql 在 initialize 包下创建 db.go,写入下列代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package initialize import ( \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; //只导入依赖，mysql驱动 \u0026#34;github.com/jmoiron/sqlx\u0026#34; \u0026#34;rmall/global\u0026#34; ) func Mysql() { //拼接dsn dsn := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%d)/%s?%s\u0026#34;, global.Config.Mysql.Username, global.Config.Mysql.Password, global.Config.Mysql.Host, global.Config.Mysql.Port, global.Config.Mysql.Dbname, global.Config.Mysql.Params, ) //dsn=root:123456@tcp(127.0.0.1:3306)/rmall?charset=utf8mb4\u0026amp;parseTime=True var err error global.Db, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) if err != nil { fmt.Println(\u0026#34;sqlx.Connect failed,err:\u0026#34;, err) return } // 最大空闲连接数 global.Db.SetMaxIdleConns(20) // 最大打开连接数 global.Db.SetMaxOpenConns(20) } 再在run.go中调用\n1 2 3 4 5 6 package initialize func Run() { LoadConfig(\u0026#34;./config.yaml\u0026#34;) Mysql() } 通过这里已经连接好 Mysql 了，现在通过global.Db就可以对数据库进行操作了\n接下来先创建用户表,在 sql 目录下创建 user.sql 写入下列内容\n1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE User ( id INT PRIMARY KEY AUTO_INCREMENT NOT NULL, username VARCHAR(50) comment \u0026#39;用户名\u0026#39;, password VARCHAR(100) comment \u0026#39;密码\u0026#39;, mobile VARCHAR(20) comment \u0026#39;手机号\u0026#39;, email VARCHAR(50) comment \u0026#39;邮箱\u0026#39;, created_at TIMESTAMP comment \u0026#39;创建时间\u0026#39;, updated_at TIMESTAMP comment \u0026#39;更新时间\u0026#39;, deleted_at TIMESTAMP comment \u0026#39;删除时间\u0026#39; ); 执行这个sql就可以创建用户表了,接下来就对用户表进行操作,在 dao 目录下创建 user.go,实现下列三个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package dao import ( \u0026#34;rmall/global\u0026#34; \u0026#34;rmall/model\u0026#34; ) // AddUser 添加用户 func AddUser(user *model.User) (id int, err error) { insertStr := `insert into user(username,password,mobile,email,created_at) values(?,?,?,?,?)` // 插入语句 res, err := global.Db.Exec(insertStr, user.Username, user.Password, user.Mobile, user.Email, user.CreatedAt) //执行插入语句 if err != nil { return 0, err } insertId, err := res.LastInsertId() return int(insertId), err //返回插入成功的id } // FindUserByUsername 根据用户名查找用户 func FindUserByUsername(username string) (user *model.User, err error) { queryStr := `select * from user where username=?` user = \u0026amp;model.User{} err = global.Db.Get(user, queryStr, username) if err != nil { return nil, err } return user, nil } // FindUserById 根据用户id查找用户 func FindUserById(Id int) (user *model.User, err error) { queryStr := `select * from user where id=?` user = \u0026amp;model.User{} err = global.Db.Get(user, queryStr, Id) if err != nil { return nil, err } return user, nil } 通过这三个函数就可添加用户,通过用户名查询用户,通过用户id查询用户了,我们需要将这几个函数封装到 service 中,在 service 下创建 user.go ,写入下列代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package service import ( \u0026#34;database/sql\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;rmall/dao\u0026#34; \u0026#34;rmall/model\u0026#34; \u0026#34;rmall/model/request\u0026#34; \u0026#34;rmall/utils\u0026#34; \u0026#34;time\u0026#34; ) // Register 用户注册 func Register(req *request.RegisterReq) (int, error) { fmt.Println(\u0026#34;hello\u0026#34;) // 参数校验 if req.Username == \u0026#34;\u0026#34; || req.Password == \u0026#34;\u0026#34; || req.Mobile == \u0026#34;\u0026#34; || req.Email == \u0026#34;\u0026#34; { return 0, errors.New(\u0026#34;参数错误\u0026#34;) } fmt.Println(\u0026#34;hello\u0026#34;) //检测用户名是否存在 user, err := dao.FindUserByUsername(req.Username) if err != nil \u0026amp;\u0026amp; !errors.Is(err, sql.ErrNoRows) { fmt.Println(err) return 0, err } if user != nil { return 0, errors.New(\u0026#34;用户名已存在\u0026#34;) } // 密码加密 hashPwd, err := utils.HashPassword(req.Password) if err != nil { return 0, err } // 保存用户信息 user = \u0026amp;model.User{ Username: req.Username, Password: hashPwd, Mobile: req.Mobile, Email: req.Email, CreatedAt: time.Now(), } //插入数据库 return dao.AddUser(user) } func Login(req *request.LoginReq) (string, int64, error) { // 参数校验 if req.Username == \u0026#34;\u0026#34; || req.Password == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, 0, errors.New(\u0026#34;参数错误\u0026#34;) } //检测用户名是否存在 user, err := dao.FindUserByUsername(req.Username) if errors.Is(err, sql.ErrNoRows) { return \u0026#34;\u0026#34;, 0, err } // 检测密码是否正确 if !utils.CheckPasswordHash(req.Password, user.Password) { return \u0026#34;\u0026#34;, 0, errors.New(\u0026#34;密码错误\u0026#34;) } token, expire, err := utils.CreateToken(user) if err != nil { return \u0026#34;\u0026#34;, 0, err } return token, expire, nil } func FindUserById(Id int) (user *model.User, err error) { return dao.FindUserById(Id) } // FindUserByUsername 通过用户名查询用户信息 func FindUserByUsername(username string) (user *model.User, err error) { return dao.FindUserByUsername(username) } 因为我们不会在 service 层直接写sql,而写 api 层是与 service 层交互,所以我们在这里实现了 FindUserById(Id int) 和 FindUserByUsername(username string),然后实现登录和注册函数,在这两个函数中,我们使用了加密函数 utils.HashPassword() 和 utils.CheckPasswordHash(),因为在数据库中我们不会明文存储密码,如果数据库被攻击,那么所有人的密码都会泄露,这是很不安全的,所以我们要对密码进行加密,在 utils 下创建 crypt.go 实现下列函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package utils import \u0026#34;golang.org/x/crypto/bcrypt\u0026#34; // HashPassword 密码加密 func HashPassword(password string) (string, error) { bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost) return string(bytes), err } // CheckPasswordHash 密码验证 func CheckPasswordHash(password, hash string) bool { err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil } 这里使用的是go的 bcrypt 包对密码进行加密和验证,在注册和登陆函数中,我们还使用了 *request.RegisterReq 和 *request.LoginReq,因为不推荐直接使用 User 这个model进行数据传输 ,所以我们在 model 下创建 request 和 response 目录,用来存放请求体和响应体,分别在两个目录下创建 user.go,写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package request // LoginReq 登陆请求 type LoginReq struct { Username string `json:\u0026#34;username\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } // RegisterReq 注册请求 type RegisterReq struct { Username string `json:\u0026#34;username\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` Mobile string `json:\u0026#34;mobile\u0026#34; binding:\u0026#34;required\u0026#34;` Email string `json:\u0026#34;email\u0026#34; binding:\u0026#34;required\u0026#34;` } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package response type LoginResp struct { Token string `json:\u0026#34;token\u0026#34;` // 过期时间 Expire int64 `json:\u0026#34;expire\u0026#34;` } type RegisterResp struct { Id int `json:\u0026#34;id\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` Mobile string `json:\u0026#34;mobile\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } type UserInfo struct { Id int `json:\u0026#34;id\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` Mobile string `json:\u0026#34;mobile\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } 到这里基本都数据库操作就完成了,有些方法还没有实现,后续慢慢添加\n","date":"2023-11-25T00:00:00Z","image":"http://rice408.cn/p/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Egin%E7%9A%84rmall%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/golang_7_hu621b4909f88eb87db6e6ae6851f9b4e0_31953_120x120_fill_q75_box_smart1.jpeg","permalink":"http://rice408.cn/p/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Egin%E7%9A%84rmall%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"从0实现基于gin的rmall商城项目（二）数据库操作"},{"content":"学习golang已经有一段时间了，一直是跟着别人的代码一个一个敲，目前有一点自己的项目理解，所以决定自己使用go来完成一个商城项目，本教程以一个小白的角度搭建，清晰易懂\n框架的选择 本项目使用 gin + sqlx + viper + casbin\n数据库：MySQL\n缓存：Redis\n接口文档：swagger\n开发环境：go1.20 、MySQL8.0 、（redis暂时还没用上）\n项目地址:https://github.com/rice408s/rmall 项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ├── api // 接口 ├── config // 配置文件 ├── docs // swagger文档 ├── dao\t//数据操作层 ├── global // 全局变量 ├── initialize // 初始化 ├── model // 数据库模型 ├── router // 路由 ├── service // 服务 ├── utils // 工具 ├── sql\t// 存放sql文件 ├── test\t// 存放测试文件 ├── config.yaml // 配置文件 ├── log.log\t// 日志文件 ├── main.go // 入口 ├── README.md // 说明文档 ├── go.mod\t// go包管理工具 项目初始化 创建初始化项目\n1 mkdir rmall \u0026amp;\u0026amp; cd rmall \u0026amp;\u0026amp; go mod init rmall 按照项目结构依次创建文件\n基础配置 我们在 config 目录下创建 config.go 文件，写入如下配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package config type Config struct { Mysql Mysql `mapstructure:\u0026#34;mysql\u0026#34; json:\u0026#34;mysql\u0026#34; yaml:\u0026#34;mysql\u0026#34;` } // Mysql MySQL配置 type Mysql struct { Host string `mapstructure:\u0026#34;host\u0026#34; json:\u0026#34;host\u0026#34; yaml:\u0026#34;host\u0026#34;` // 主机名 Port int `mapstructure:\u0026#34;port\u0026#34; json:\u0026#34;port\u0026#34; yaml:\u0026#34;port\u0026#34;` // 端口号 Username string `mapstructure:\u0026#34;username\u0026#34; json:\u0026#34;username\u0026#34; yaml:\u0026#34;username\u0026#34;` // 用户名 Password string `mapstructure:\u0026#34;password\u0026#34; json:\u0026#34;password\u0026#34; yaml:\u0026#34;password\u0026#34;` // 密码 Dbname string `mapstructure:\u0026#34;dbname\u0026#34; json:\u0026#34;dbname\u0026#34; yaml:\u0026#34;dbname\u0026#34;` // 数据库名 Params string `mapstructure:\u0026#34;params\u0026#34; json:\u0026#34;params\u0026#34; yaml:\u0026#34;params\u0026#34;` // 链接参数 } 然后在 global 下创建 global.go 文件，写入下列代码\n1 2 3 4 5 6 7 8 9 10 package global import ( \u0026#34;rmall/config\u0026#34; ) // 定义全局变量 var ( Config config.Config ) 通过全局变量，我们就可以轻松的访问配置文件中的数据了\n编写配置文件 这里的配置文件使用的是 yaml 文件，我们在项目的根目录下创建 config.yaml，写入如下配置\n1 2 3 4 5 6 7 mysql: host: \u0026#34;127.0.0.1\u0026#34; port: \u0026#34;3306\u0026#34; username: \u0026#34;root\u0026#34; password: \u0026#34;123456\u0026#34; dbname: \u0026#34;rmall\u0026#34; params: \u0026#34;charset=utf8mb4\u0026amp;parseTime=True\u0026#34; 这里的配置文件的值根据自己的实际情况去书写\n载入配置文件 这里使用的go的viper包来加载配置文件，获取viper包\n1 go get github.com/spf13/viper 在 initialize 目录下创建 config.go ，写入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package initialize import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;rmall/global\u0026#34; ) func LoadConfig(path string) { viper.SetConfigFile(path) viper.SetConfigName(\u0026#34;config\u0026#34;) //文件名为config viper.SetConfigType(\u0026#34;yaml\u0026#34;)\t//文件后缀为yaml //添加配置文件所在的路径，注意在Linux环境下%GOPATH要替换为$GOPATH viper.AddConfigPath(\u0026#34;.\u0026#34;)\t//配置文件路径 if err := viper.ReadInConfig(); err != nil { fmt.Println(\u0026#34;viper.ReadInConfig failed,err:\u0026#34;, err) return } err := viper.Unmarshal(\u0026amp;global.Config) //将读取到的配置解析到创建的全局变量上 if err != nil { fmt.Println(\u0026#34;viper.Unmarshal failed,err:\u0026#34;, err) return } } 再在 initialize 目录下创建 run.go，写入下列代码\n1 2 3 4 5 package initialize func Run() { LoadConfig(\u0026#34;./config.yaml\u0026#34;) //配置文件的路径 } 再在 main.go 中添加下列代码\n1 2 3 4 5 6 7 8 9 package main import ( \u0026#34;rmall/initialize\u0026#34; ) func main() { initialize.Run() } 这样配置文件就配置完成了，之后的函数调用都可以写在 Run() 方法中，这样 main() 只需要调用 Run() 就行了，保持简洁\n","date":"2023-11-22T00:00:00Z","image":"http://rice408.cn/p/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Egin%E7%9A%84rmall%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B8%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/golang_6_hu52ed627a3c4988aa525d5b1762dbe555_39559_120x120_fill_q75_box_smart1.jpeg","permalink":"http://rice408.cn/p/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Egin%E7%9A%84rmall%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B8%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"从0实现基于gin的rmall商城项目（一）配置文件"}]